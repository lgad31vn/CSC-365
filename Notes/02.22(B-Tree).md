
# B-Tree

## Convention
  - A self-balencing search tree
  - A B-Tree of order *m* is a tree that satisfies:
    + Every node has at most m children
    + Every non-leaf node (except root) has at least [m/2] child nodes
    + Every non-leaf node has at least two children
    + A non-leaf node with k children contains k-1 keys
    + All leaves appear in the same level and carry no information

## B-Tree concept
  - ### When the number of keys is high, the data is read from disk in the form of blocks.
  - The main idea of using B-Trees is to reduce the number of disk accesses
  - Most of the tree operations (search, insert, delete, max, min, ..etc ) require O(h) disk accesses where h is the height of the tree
  - The height of B-Trees is kept low by putting maximum possible keys in a B-Tree node
  - Generally, the B-Tree node size is kept equal to the disk block size
  - Since the height of the B-tree is low so total disk accesses for most of the operations are reduced significantly compared to balanced Binary Search Trees like AVL Tree, Red-Black Tree, ..etc

<img width="675" alt="image" src="https://user-images.githubusercontent.com/66233296/156902803-b93f686e-53e4-4767-afea-3eb9190639d1.png">

## B-tree's Properties
<img width="713" alt="image" src="https://user-images.githubusercontent.com/66233296/156902816-1353e740-2249-495d-83af-daf62a86fab2.png">


```
class BT{

  class BTree{

    int k; // order
    Object[] keys = new Object[MAXK];
    Btree[] child = new Btree[MAXK];
    Btree parent;
    
  }
  
}
```


## Persistent data store
  - block/buffers (research more)
 -data format
      - marshiling, externilization, serialization
      - primitives (ex: int)
      - Strings 
        - ascii
        - fixed
        - Unicode : UTF-8 (standard nowadays, consise), UTF-16(Chinese alphabet)
        - Pointer/releases
          - only allow for the data store as offset
          - recursive
      








